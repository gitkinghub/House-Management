ALLOWED_HOSTS -> tells django which hosts can use the api. set it to your url or asterisk (*) for all hosts
DEBUG -> shows helpful errors in the api when it is set to True.

						Django ORM
						-----------
ORM -> Object Relational Mapper
It maps the model classes created using django into SQL queries which are used to write into the database


						Saving images to files
						----------------------
once you have created the image field in your class model of type filefield, you have to provide the 'upload_to' argument path.
To do that, you need to define a custom location where the image is going to be uploaded by creating a deconstructible class.
1. Import the deconstructibe constructor from django. -> it allows your custom class to be taken in by django and be converted into a migration.
2. Create your custom class nam which inherits from object and use the deconstructible decorator
3. Define the __init__ method with pass -> this shows that it doesn't require arguments when instantiated
4. Make your class callable by creating the __call__ method. This makes sure that the instance of the class can be used as a function. It should take the instance and filename parameters. Where instance is the instance of the original model class and filename is the original name of the uploaded image
5. Create a field inside the call method to extract the filename extension: i.e ext=filename.split('.')[-1]
6. Another field for path where the file will be saved. ie. path = f'media/accounts/{instance.user.id}/images/'
7. Another field to define the name of the uploaded image. i.e name = f'profile_image.{ext}'
8. Return the complete path and the name. i.e return os.path.join(path, name)
9. Create a gloabal variable which will hold the instance to the path class i.e user_profile_image_path = GenerateProfileImagePath() then assign that variable to 'upload_to=' as argument.


							Model Creation
							--------------
Once you have created your model, you need to register them in the admin file so they can appear in django admin.
admin.site.register(Profile, ProfileAdmin). You also need to specify the fields to be listed in django admin like name etc; to do that, you need to create the admin representation of your model with the fields you want displayed and remember to register this class also.
e.g
class ProfileAdmin(admin.ModelAdmin):
    readonly_fields = ('id',)
    
In your original model class, def a string function to convert the fields into a string reprsentation of the object.
e.g
def __str__(self):
        return f'{self.user.username}\'s Profile'


							Creating Serializers
							--------------------
DRF works behind these three parts:
	Routers that route the traffic coming to our API to a specific endpoint.
	Viewsets that act as method handlers that allow the API to understand the context of data it has been given to it and return the appropriate data back
	Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON, XML or other content types


							Defining global and local permissions 
							-------------------------------------
To set up permissions for your rest framework, you need to set them in your settings file. 
Django provides a set of permission classes: https://www.django-rest-framework.org/api-guide/permissions/ which you can use.
e.g
REST_FRAMEWORK = {
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticatedOrReadOnly",
    ]
}
we can also define permissions for viewsets for first time users who don't have an account to be able to create other users. the way to do that is to create a permissions.py file inside your app that are specific to the viewset that bypass the ones in the settings file.
example:
	check the IsUserOwnerOrGetAndPostOnly in permission.py file

then in the viewset file, you need to add the class as part of the permission class.
i.e     permission_classes = [IsUserOwnerOrGetAndPostOnly]

what this does, it allows a non-authenticated user to be able to create a new user and see the list of users since we're overriding the permission in the setting file with the the first and second(first if condition) function in the permission file
we cannot however edit the information for a given user since that's not our Profile.


							ADDING AUTHENTICATION FOR LOGIN AND LOGOUT
							------------------------------------------
			
			1. USING BROWSABLE API SESSION AUTHENTICATION
			---------------------------------------------

Django provides routes for simple authentication for the API. When you include the url routes from django, you make the following authentication views available.
	login/: handles login requests
	logout/: handles logout requests
	password/reset/: handles password reset requests
	password/reset/confirm/: handles password reset confirmation requests
The routes are found in the 'rest_framework.urls' module - example:
	auth_api_urls = []

	if settings.DEBUG:
		auth_api_urls = [
			path('api-auth/', include('rest_framework.urls')),
		]
After setting the django routes, we need to disable DRF session based authentication inside of our API. We specify the authentication class to be used inside our django rest framework.
We have two authentication classes, basic authentication and session authentication - they allow the login ability and logout for the rest framework
to add the authentication classes, add another key(DEFAULT_AUTHENTICATION_CLASSES) in the rest framework dictionary in settings file: example:
	"DEFAULT_AUTHENTICATION_CLASSES": [
			# rest framework authentication classes
			'rest_framework.authentication.BasicAuthentication',
			'rest_framework.authentication.SessionAuthentication',
		]

			2. TOKEN BASED AUTHENTICATION
			-----------------------------
Refer to the drf documentation but in our project, i have used oauth2 social.
You have to install it with this command: pip install django-rest-framework-social-oauth2
Then, in the installed apps in settings file you add three new apps: "oauth2_provider", "social_django", "rest_framework_social_oauth2",
In the routes url for auth_api_urls, you include all the endpoints that come from the rest_framework_social_oauth2 url then include the context processors in the settings file
	social_django.context_processors.backends
	social_django.context_processors.login_redirect

Then we have to tell django to use jason web token authentication same as we did in the rest framework authentication classes.
In the rest framework dictionary,  add these classes:
		# oauth(token) based authentication
        "oauth2_provider.contrib.rest_framework.OAuth2Authentication",
        "rest_framework_social_oauth2.authentication.SocialAuthentication",
Then add authentication backends for oauth2 and django:
	AUTHENTICATION_BACKENDS = (
    # OAuth2
    "oauth2_provider.backends.OAuth2Backend",
    # Django
    "django.contrib.auth.backends.ModelBackend",
)


								IMPLEMENTING PASSWORD CHANGE FUNCTIONALITY
								------------------------------------------
Validation work is done in the serializer.
Define an update function and pass the user instance and validated_data arguments to the function.
def update(self, instance, validated_data):
        user = instance
        try:
            if "password" in validated_data:
                password = validated_data.pop("password")
                old_password = validated_data.pop("old_password")
                if user.check_password(old_password):
                    user.set_password(password)
                else:
                    raise serializers.ValidationError("Old password is incorrect")
                user.save()
        except Exception as err:
            raise serializers.ValidationError(err)    

        return super(UserSerializer, self).update(instance, validated_data)

we use the pop method instead of the get method because we want to remove the associated key-value pair from the dictionary after receiving its value.
then we return a call to the super class in modelserialize since we want add custom logic to the update method but still leverage the default behavior of the parent class of updating the instance.
Generic viewset allows us to specify which permission to include in our viewset.    


											
											IMPLEMENTING VALIDATION LOGIC IN SERIALIZER
											-------------------------------------------
To validate data being sent to the serializer, we use the validate() method where be pass attrs argument that has all attributes passed to the serializer.
When we want to validate only one attribute, we use the validate methos coupled with the name of the attribute. i.e. validate_task_list(self, value) -> validates the task list attribute.
Value is the value of the attribute being validated.